{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/rutvikpatel/Desktop/Project/Github6/starter_kit/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/rutvikpatel/Desktop/Project/Github6/starter_kit/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar EventIterator =\n/*#__PURE__*/\nfunction () {\n  function EventIterator(listen, remove) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, EventIterator);\n\n    this.listen = listen;\n    this.remove = remove;\n    this.options = Object.assign({\n      highWaterMark: 100\n    }, options);\n    Object.freeze(this);\n  }\n\n  _createClass(EventIterator, [{\n    key: Symbol.asyncIterator,\n    value: function value() {\n      var _this = this;\n\n      var placeholder;\n      var queue = [];\n      var listen = this.listen;\n      var remove = this.remove;\n\n      var push = function push(value) {\n        var resolution = {\n          value: value,\n          done: false\n        };\n\n        if (placeholder) {\n          placeholder.resolve(resolution);\n          placeholder = undefined;\n        } else {\n          queue.push(Promise.resolve(resolution));\n          var highWaterMark = _this.options.highWaterMark;\n\n          if (highWaterMark !== undefined && queue.length >= highWaterMark && console) {\n            console.warn(\"EventIterator queue reached \".concat(queue.length, \" items\"));\n          }\n        }\n      };\n\n      var stop = function stop() {\n        if (remove) {\n          remove(push, stop, fail);\n        }\n\n        var resolution = {\n          done: true\n        };\n\n        if (placeholder) {\n          placeholder.resolve(resolution);\n          placeholder = undefined;\n        } else {\n          queue.push(Promise.resolve(resolution));\n        }\n      };\n\n      var fail = function fail(error) {\n        if (remove) {\n          remove(push, stop, fail);\n        }\n\n        if (placeholder) {\n          placeholder.reject(error);\n          placeholder = undefined;\n        } else {\n          var rejection = Promise.reject(error);\n          /* Attach error handler to avoid leaking an unhandled promise rejection. */\n\n          rejection.catch(function () {});\n          queue.push(rejection);\n        }\n      };\n\n      listen(push, stop, fail);\n      return {\n        next: function next(value) {\n          if (queue.length) {\n            return queue.shift();\n          } else {\n            return new Promise(function (resolve, reject) {\n              placeholder = {\n                resolve: resolve,\n                reject: reject\n              };\n            });\n          }\n        },\n        return: function _return() {\n          if (remove) {\n            remove(push, stop, fail);\n          }\n\n          return Promise.resolve({\n            done: true\n          });\n        }\n      };\n    }\n  }]);\n\n  return EventIterator;\n}();\n\nexports.EventIterator = EventIterator;\nexports.default = EventIterator;","map":null,"metadata":{},"sourceType":"script"}
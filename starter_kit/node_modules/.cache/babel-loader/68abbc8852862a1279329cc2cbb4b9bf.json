{"ast":null,"code":"/** @module promise-nodeify\n * @copyright Copyright 2016-2018 Kevin Locke <kevin@kevinlocke.name>\n * @license MIT\n */\n'use strict';\n/** Function which will run with a clear stack as soon as possible.\n * @private\n */\n\nvar later = typeof process !== 'undefined' && typeof process.nextTick === 'function' ? process.nextTick : typeof setImmediate === 'function' ? setImmediate : setTimeout;\n/** Invokes callback and ensures any exceptions thrown are uncaught.\n * @private\n */\n\nfunction doCallback(callback, reason, value) {\n  // Note:  Could delay callback call until later, as When.js does, but this\n  // loses the stack (particularly for bluebird long traces) and causes\n  // unnecessary delay in the non-exception (common) case.\n  try {\n    // Match argument length to resolve/reject in case callback cares.\n    // Note:  bluebird has argument length 1 if value === undefined due to\n    // https://github.com/petkaantonov/bluebird/issues/170\n    // If you are reading this and want similar behavior, I'll consider it.\n    if (reason) {\n      callback(reason);\n    } else {\n      callback(null, value);\n    }\n  } catch (err) {\n    later(function () {\n      throw err;\n    });\n  }\n}\n/** Calls a node-style callback when a Promise is resolved or rejected.\n *\n * This function provides the behavior of\n * {@link https://github.com/then/nodeify then <code>nodeify</code>},\n * {@link\n * https://github.com/cujojs/when/blob/master/docs/api.md#nodebindcallback\n * when.js <code>node.bindCallback</code>},\n * or {@link http://bluebirdjs.com/docs/api/ascallback.html bluebird\n * <code>Promise.prototype.nodeify</code> (now\n * <code>Promise.prototype.asCallback</code>)} (without options).\n *\n * @ template ValueType\n * @param {!Promise<ValueType>} promise Promise to monitor.\n * @param {?function(*, ValueType=)=} callback Node-style callback to be\n * called when <code>promise</code> is resolved or rejected.  If\n * <code>promise</code> is rejected with a falsey value the first argument\n * will be an instance of <code>Error</code> with a <code>.cause</code>\n * property with the rejected value.\n * @return {Promise<ValueType>|undefined} <code>undefined</code> if\n * <code>callback</code> is a function, otherwise a <code>Promise</code>\n * which behaves like <code>promise</code> (currently is <code>promise</code>,\n * but is not guaranteed to remain so).\n * @alias module:promise-nodeify\n */\n\n\nfunction promiseNodeify(promise, callback) {\n  if (typeof callback !== 'function') {\n    return promise;\n  }\n\n  function onRejected(reason) {\n    // callback is unlikely to recognize or expect a falsey error.\n    // (we also rely on truthyness for arguments.length in doCallback)\n    // Convert it to something truthy\n    var truthyReason = reason;\n\n    if (!truthyReason) {\n      // Note:  unthenify converts falsey rejections to TypeError:\n      // https://github.com/blakeembrey/unthenify/blob/v1.0.0/src/index.ts#L32\n      // We use bluebird convention for Error, message, and .cause property\n      truthyReason = new Error(String(reason));\n      truthyReason.cause = reason;\n    }\n\n    doCallback(callback, truthyReason);\n  }\n\n  function onResolved(value) {\n    doCallback(callback, null, value);\n  }\n\n  promise.then(onResolved, onRejected);\n  return undefined;\n}\n/** A version of {@link promiseNodeify} which delegates to the\n * <code>.nodeify</code> method on <code>promise</code>, if present.\n *\n * This may be more performant than {@see promiseNodeify} and have additional\n * implementation-specific features, but the behavior may differ from\n * <code>promiseNodeify</code> and between Promise implementations.\n *\n * Note that this function only passes the callback argument to\n * <code>.nodeify</code>, since additional arguments are interpreted\n * differently by different libraries (e.g. bluebird treats the next argument\n * as an options object while then treats it as <code>this</code> for the\n * callback).\n *\n * @ template ValueType\n * @param {!Promise<ValueType>} promise Promise to monitor.\n * @param {?function(*, ValueType=)=} callback Node-style callback.\n * @return {Promise<ValueType>|undefined} Value returned by\n * <code>.nodeify</code>.  Known implementations return the\n * <code>promise</code> argument when callback is falsey and either\n * <code>promise</code> or <code>undefined</code> otherwise.\n */\n\n\npromiseNodeify.delegated = function nodeifyDelegated(promise, callback) {\n  if (typeof promise.nodeify === 'function') {\n    return promise.nodeify(callback);\n  }\n\n  return promiseNodeify(promise, callback);\n};\n/** Polyfill for <code>Promise.prototype.nodeify</code> which behaves like\n * {@link promiseNodeify}.\n *\n * @ template ValueType\n * @this {!Promise<ValueType>}\n * @param {?function(*, ValueType=)=} callback Node-style callback.\n * @return {Promise<ValueType>|undefined} <code>undefined</code> if\n * <code>callback</code> is a function, otherwise a <code>Promise</code>\n * which behaves like <code>promise</code> (currently is <code>promise</code>,\n * but is not guaranteed to remain so).\n */\n\n\npromiseNodeify.nodeifyThis = function nodeifyThis(callback) {\n  return promiseNodeify(this, callback);\n}; // Note: This file is used directly for Node and wrapped in UMD for browser\n\n\nif (typeof exports === 'object') {\n  module.exports = promiseNodeify;\n}","map":null,"metadata":{},"sourceType":"script"}